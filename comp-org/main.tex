\documentclass[11pt,letterpaper]{article}

% Load package
\usepackage{lesson}

%--------------------------------------%
% Custom commands include:             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Include an image:                    %
% \diagram{height}{align}{file}        %
%                                      %
% height: a number representing mm     %
% align: left, center, or right        %
% file: file name without extension    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Add a numbered question:             %
% \question{text}                      %
% \questiond[lines]{file}{width}{text} %
%                                      %
% lines: # of lines of text to wrap    %
% file: file name without extension    %
% width: a % of textwidth for image    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Add a lettered option/question part: %
% \option[vspace]{text}                %
%                                      %
% vspace: added space above the option %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Add a blank line in text:            %
% \blankline{width}                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Add an arc symbol in math:           %
% \arc{notation}                       %
%--------------------------------------%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%--------------------------------------%
% To reset the question counter:       %
% \setcounter{qcounter}{0}             %
%                                      %
% To reset the option counter:         %
% \setcounter{acounter}{0}             %
%--------------------------------------%

% Set title and course name
\settitle{\textbf{1}}
\setsubtitle{}
\setcourse{EE2003}

\begin{document}

% Create title and add proper header for first page
\maketitle
\thispagestyle{first}
\section*{Intel 8086}
\diagram{70}{center}{8086.jpg}
\subsection*{Execution Unit}
\begin{itemize}
	\item Flag register used to store some result about an operation. Example
		result of a comparision or overflow bit etc. Used by the ALU
	\item E(xtended)SP: Stack pointer
	\item EA/B/C/D: General registers. Do whatever you want
	\item ESI/ EDI: For string instructions. strlen() or memcpy()
\end{itemize}

The Extended registers \textbf{extend} the A/B/C/DX registers to 32 bit

\subsection*{Bus Interface Unit}
\textbf{CS, SS, DS} store the starting address of code, stack and data segments.
The IP(instruction pointer) or the {A,B,C,D} registers are used to store the offset from the start address.
Formula is given by:  \[Address = Segment << 4 + offset\]

BP and SP point to SS, IP points to CS, A/B/C/D point to DS (or ES, prof did not remember)


\settitle{\textbf{2}}
\subsection*{x86 Ops}
\begin{minted}[linenos,frame=single]{nasm}
MOV EAX, EBX       ; EAX <- EBX, register direct
MOV EAX, [ECX]     ; Load from memory, register indirect
MOV [ECX], EAX     ; store to memory
MOV EAX, [EBX - N] ; register indirect with offset, requires the EDS as well
MOV EAX, 0x1602    ; immediate mode, no address calculation required
MOV EAX, EBX - ECX ; THIS IS WRONG


; Load Effective Addr:
; Essentially you can do math in the right operand.
; Used in compilers for things like
; int *p = &point[i].ycoord;
LEA EAX, [EBP+8*EAX+4]

; ALU Ops
ADD EAX, EBX	; EAX <- EAX + EBX
SUB EAX, DWORD PTR[EBX]
SUB EAX, WORD PTR[EBX]
SUB EAX, BYTE PTR[EBX]

; Logical Ops
AND EAX, DWORD PTR [EBP + 4]
\end{minted}

\question{
Write assembly to do the following:
\newline
$EAX = x*y + a-b$
\newline
$EBX = (x \oplus y) | (a \wedge b)$
}

\begin{minted}[linenos,frame=single]{nasm}
; first part
MOV EAX, X
MUL y
MOV EBX, a
SUB EBX, b
ADD EAX, EBX

;second part
MOV EBX, x
XOR EBX, y
MOV ECX, a
AND ECX, b
OR EBX, ECX
\end{minted}

\pagebreak
\question{Write a program to evaluate $z = x * y$ using repeated addition}
\begin{minted}[linenos, frame=single]{nasm}
XOR EAX, EAX
MOV EBX, y
CMP EBX, 0
JZ done
add:	
ADD EAX, x
DEC EBX
JNZ add

done:
NOP
\end{minted}
\question{Write a program to calculate the string length of a constant string}
\begin{minted}[linenos, frame=single]{nasm}
; assuming the data is little endian
XOR EAX, EAX
loop: 
CMP [EBX], 0
JZ done
INC EBX
INC EAX
JMP loop

done:
NOP
\end{minted}

\question{Write a program to swap two integers x and y}
\begin{minted}[linenos, frame=single]{c}
Swap(int *pX, int *pY){
	__asm{
		MOV EAX, pX
		MOV EBX, pY

		PUSH DWORD PTR [EAX]
		PUSH DWORD PTR [EBX]
		POP DWORD PTR [EAX]
		POP DWORD PTR [EBX]
	}
}
\end{minted}

\pagebreak

\question{Look at these swaps and realize the differences}
\begin{minted}[linenos, frame=single]{c}
Swap(int *pX, int *pY){
	__asm{
		; this thing is like gae
		; the most useless thing ever
		PUSH pX
		PUSH pY
		POP pX
		POP pY
	}
}

Swap2(int x, int y){
	__asm{
		; this thing is like gae
		; the most useless thing ever
		PUSH x 
		PUSH y 
		POP x
		POP y
	}
}

Swap3(int *pX, int *pY){
	__asm{
		; this thing is not gae
		MOV EAX, pX
		MOV EBX, pY
		PUSH DWORD PTR [EAX]
		PUSH DWORD PTR [EBX]
		POP DWORD PTR [EAX]
		POP DWORD PTR [EBX]
	}
}
\end{minted}


\section*{Compiling a C program}
\fbox{\begin{minipage}{\textwidth}
\subsection*{Optimization}
You can optimize your \texttt{*.c} code by using the \texttt{\textbackslash O1} flag if using MSVC.
It removes dead code and can optimize to reduce intstructions. However one should
be very careful and not trust the compiler to do their job perfectly all the time.
\end{minipage}
}

\begin{minted}[linenos, frame=single]{c}
int __stdcall Fn(int x, int y){
	/*
	* Prologue
	* PUSH EBP	; store the previous base
	* MOV EBP, ESP	; set the top as the new base
	* SUB ESP, 0x40 ; leave some space out for local variables(?)
	*/
	// MOV [EBP-4], 0
	int z = 0;
	z = x+y;
	/* MOV EAX, 8[EBP]
	*  MOV EBX, 12[EBP]
	*  ADD EAX, EBX
	*/
	MOV [EBP-4], EAX
	return z;
	/* Epilogue
	*  ADD ESP, 0x40
	*  POP EBP
	*  RET 8	; doing __stdcall forces compiler to do the 
	*		; stack cleanup
	*/
}
int main(){
	int z=0;
	z = Fn(2,4);
}
\end{minted}

\fbox{\begin{minipage}{\textwidth}
\subsection*{Optimization}
\texttt{\_\_stdcall} forces the callee to do the stack cleanup. Normal behaviour is
\texttt{RET 0} in the callee function and \texttt{ADD ESP, N} in the caller function. Directly doing \texttt{RET N} is faster(by one clock cycle) but you cannot do
variable arguments.
\end{minipage}}

\subsection*{Pushing parameters}
The parameters passed to a function are pushed from right to left. For a call like:
\[f(a, b, c ... z)\]

the stack will look like:
\newline
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
	\hline a & b & c & ... & z\\
	\hline ESP & & & & EBP \\
	\hline
\end{tabular}
\end{center}


\fbox{\begin{minipage}{\textwidth}
\subsection*{Optimization}
\texttt{\_\_fastcall} is a calling convention( specific to MSVC ) that asks the compiler to use registers to store parameters( wherever possible ). This will speed
up memory access.
\end{minipage}
}

\subsection*{Recursion}
\begin{minted}[linenos, frame=single]{c}
int fact(int n)
{
	int ans = 1;
	if(0 != n){
		ans = n*fact(n-1);
	}
	return ans;
}

int main()
{
	int ans = 0;
	ans = fact(3);
}
\end{minted}
This gives the assembly output as:
\begin{minted}[linenos, frame=single]{nasm}
	; Prologue
	PUSH EBP
	MOV EBP, ESP
	PUSH ECX

	MOV EAX, 1
	MOV EBX, [EBP+8]
	MOV [EBP-4], EAX
	CMP EBX, 0
	JZ DONE
	DEC EBX
	PUSH EBX
	CALL fact
	ADD ESP, 4
	MUL [EBP+8]

DONE:
	; Epilogue
	ADD ESP, 4
	POP EBP
	RET 0
\end{minted}
\pagebreak
The stack will look like(NOTE it grows downwards): 

\begin{center}
\begin{tabular}{|c|}
	\hline
	ans-main \\
	\hline
	3 \\
	\hline
	ret-addr-main \\
	\hline
	EBP-main \\
	\hline
	ans-fact1 \\
	\hline
	2 \\
	\hline
	ret-addr1(0xC200) \\
	\hline
	EBP-fact1 \\
	\hline
	ans-fact2 \\
	\hline
	1 \\
	\hline
	ret-addr2(0xC200) \\
	\hline
	EBP-fact2 \\
	\hline
	ans-fact3 \\
	\hline
	0 \\
	\hline
	ret-addr3(0xC200) \\
\end{tabular}
\end{center}
\end{document}

